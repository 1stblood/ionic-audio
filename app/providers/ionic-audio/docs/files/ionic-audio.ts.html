<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>ionic-audio.ts</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-elements">Elements</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AudioProvider.html">AudioProvider</a></li>
                                <li><a href="../classes/AudioTimePipe.html">AudioTimePipe</a></li>
                                <li><a href="../classes/AudioTrack.html">AudioTrack</a></li>
                                <li><a href="../classes/AudioTrackComponent.html">AudioTrackComponent</a></li>
                                <li><a href="../classes/AudioTrackPlayComponent.html">AudioTrackPlayComponent</a></li>
                                <li><a href="../classes/AudioTrackProgressBarComponent.html">AudioTrackProgressBarComponent</a></li>
                                <li><a href="../classes/AudioTrackProgressComponent.html">AudioTrackProgressComponent</a></li>
                                <li><a href="../classes/CordovaAudioTrack.html">CordovaAudioTrack</a></li>
                                <li><a href="../classes/WebAudioProvider.html">WebAudioProvider</a></li>
                            </ul>
                
                                <ul id="api-elements" class="apis elements">
                                    <li><a href="../elements/audio-track.html">&lt;audio-track&gt;</a></li>
                                    <li><a href="../elements/audio-track-play.html">&lt;audio-track-play&gt;</a></li>
                                    <li><a href="../elements/audio-track-progress.html">&lt;audio-track-progress&gt;</a></li>
                                    <li><a href="../elements/audio-track-progress-bar.html">&lt;audio-track-progress-bar&gt;</a></li>
                                </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/ionic-audio.html">ionic-audio</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: ionic-audio.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">

/**
 * An audio player for Ionic 2 and Angular 2
 *
 * @module ionic-audio
 */

import {IAudioProvider, ITrackConstraint, IAudioTrack} from &#x27;./ionic-audio.d.ts&#x27;; 
import {Component, Directive, DoCheck, SimpleChange, EventEmitter, ElementRef, Renderer, Output, Input, Injectable, Inject, Optional, Pipe, PipeTransform} from &#x27;angular2/core&#x27;;
import {NgStyle} from &#x27;angular2/common&#x27;;
import {Http} from &#x27;angular2/http&#x27;;
import {Icon} from &#x27;ionic-angular&#x27;;
import {DragGesture} from &#x27;ionic-angular/gestures/drag-gesture&#x27;;

declare let webkitAudioContext;
declare let Media: any;

export * from &#x27;./ionic-audio.d.ts&#x27;;

/**
 * Base class for audio providers
 * 
 * @export
 * @abstract
 * @class AudioProvider
 * @implements {IAudioProvider}
 */
@Injectable()
export abstract class AudioProvider implements IAudioProvider {
  protected static tracks: IAudioTrack[] = [];
  protected _current: number;
  
  /**
   * Creates an audio provider based on the environment.
   * If running from within a browser, then defaults to HTML5 Audio. If running on a device, it will check for Cordova and Media plugins and use
   * a native audio player, otherwise falls back to HTML5 audio.  
   * 
   * @method factory
   * @static
   * @return {IAudioProvider} An IAudioProvider instance 
   */
  static factory() {
    return new WebAudioProvider();
  }
  
  constructor() {
  }
  
  /**
   * Creates an IAudioTrack instance from a JSON object.
   * Not implemented in base class.
   * 
   * @method create
   * @param {ITrackConstraint} track A JSON object containing at least a src property
   * @return null
   */
  create(track: ITrackConstraint) {
    return null;
  }
  
  /**
   * Adds an existing IAudioTrack instance to the array of managed tracks.
   *
   * @method add 
   * @param {IAudioTrack} audioTrack An instance of IAudioTrack
   */
  add(audioTrack: IAudioTrack) {
    AudioProvider.tracks.push(audioTrack);  
  };
  
  /**
   * Plays a given track.
   * 
   * @method play
   * @param {number} index The track id
   */
  play(index: number) {
    if (index===undefined || index &gt; AudioProvider.tracks.length-1) return;
    this._current = index;
    AudioProvider.tracks[index].play();  
  };
  
  /**
   * Pauses a given track.
   * 
   * @method pause
   * @param {number} [index] The track id, or if undefined it will pause whichever track currently playing
   */
  pause(index?: number) {
    if (this._current===undefined || index &gt; AudioProvider.tracks.length-1) return;
    index = index || this._current;
    AudioProvider.tracks[index].pause();
  };
  
  /**
   * Stops a given track.
   * 
   * @method stop
   * @param {number} [index] The track id, or if undefined it will stop whichever track currently playing
   */
  stop(index?: number) {
    if (this._current===undefined || index &gt; AudioProvider.tracks.length-1) return;
    index = index || this._current;
    AudioProvider.tracks[index].stop();
    this._current = undefined;
  };
  
  /**
   * Gets an array of tracks managed by this provider
   * 
   * @property tracks
   * @readonly
   * @type {IAudioTrack[]}
   */
  public get tracks() : IAudioTrack[] {
    return AudioProvider.tracks;
  }
  
  /**
   * Gets current track id
   * 
   * @property current
   * @type {number}
   */
  public get current() : number {
    return this._current;
  }
  
  /**
   * Sets current track id
   * 
   * @property current
   */
  public set current(v : number) {
    this._current = v;
  }
  
}

/**
 * Creates an HTML5 audio provider
 * 
 * @export
 * @class WebAudioProvider
 * @constructor
 * @extends {AudioProvider}
 */
@Injectable()
export class WebAudioProvider extends AudioProvider {
  
  constructor() {
    super();
  }
  
  create(track: ITrackConstraint) {
    let audioTrack = new AudioTrack(track.src, track.preload);  
    Object.assign(audioTrack, track);
    let trackId = WebAudioProvider.tracks.push(audioTrack);
    audioTrack.id = trackId-1; 
    return audioTrack;
  }
  
}

/**
 * Creates an HTML5 audio track
 * 
 * @export
 * @class AudioTrack
 * @constructor
 * @implements {IAudioTrack}
 */
@Injectable()
export class AudioTrack implements IAudioTrack {
  private audio: HTMLAudioElement;
  public isPlaying: boolean = false;
  public isFinished: boolean = false;
  private _progress: number;
  private _completed: number;
  private _duration: number;
  private _id: number;
  private _isLoading: boolean;
  private _hasLoaded: boolean;
  constructor(public src: string, @Optional() public preload: string = &#x27;none&#x27;, @Optional() private ctx: AudioContext = new (AudioContext || webkitAudioContext)()) {
    this.createAudio(); 
  
    this.audio.addEventListener(&quot;timeupdate&quot;, (e) =&gt; { this.onTimeUpdate(e); }, false);
    
    this.audio.addEventListener(&quot;error&quot;, (err) =&gt; {
      console.log(&#x60;Audio error =&gt; track ${src}&#x60;, err);
      this.isPlaying = false;
    }, false);
    
    this.audio.addEventListener(&quot;canplay&quot;, () =&gt; {
      console.log(&#x60;Loaded track ${this.src}&#x60;);
      this._isLoading = false;
      this._hasLoaded = true;
    }, false);
    
    this.audio.addEventListener(&quot;playing&quot;, () =&gt; {
      console.log(&#x60;Playing track ${this.src}&#x60;);
      this.isFinished = false;
      this.isPlaying = true;
    }, false);
    
    this.audio.addEventListener(&quot;ended&quot;, () =&gt; {
      this.isPlaying = false;
      this.isFinished = true;
      console.log(&#x27;Finished playback&#x27;);
    }, false);
    
    this.audio.addEventListener(&quot;durationchange&quot;, (e:any) =&gt; {    
      this._duration = e.target.duration;
    }, false);
  }
  
  private createAudio() {
    this.audio = new Audio();
    this.audio.src = this.src;
    this.audio.preload = this.preload;
    //this.audio.controls = true;
    //this.audio.autoplay = false;  
  }
  
  private onTimeUpdate(e: Event) {
    if (this.isPlaying &amp;&amp; this.audio.currentTime &gt; 0) {
      this._progress = this.audio.currentTime;
      this._completed = this.audio.duration &gt; 0 ? this.audio.currentTime / this.audio.duration : 0;
    }  
  }
  
  static formatTime(value:number) {
    let s = Math.trunc(value % 60);
    let m = Math.trunc((value / 60) % 60);
    let h = Math.trunc(((value / 60) / 60) % 60);  
    return h &gt; 0 ? &#x60;${h&lt;10?&#x27;0&#x27;+h:h}:${m&lt;10?&#x27;0&#x27;+m:m}:${s&lt;10?&#x27;0&#x27;+s:s}&#x60; : &#x60;${m&lt;10?&#x27;0&#x27;+m:m}:${s&lt;10?&#x27;0&#x27;+s:s}&#x60;;
  } 
  
  
  /**
   * Gets the track id
   * 
   * @property id
   * @type {number}
   */
  public get id() : number {
    return this._id;
  }
  
  /**
   * Sets the track id
   * 
   * @property id
   */
  public set id(v : number) {
    this._id = v;
  }
  
  /**
   * Gets the track duration, or -1 if it cannot be determined
   * 
   * @property duration
   * @readonly
   * @type {number}
   */
  public get duration() : number {
    return this._duration;
  }
  
  /**
   * Gets current track time (progress)
   * 
   * @property progress
   * @readonly
   * @type {number}
   */
  public get progress() : number {
    return this._progress;
  }
  
  /**
   * Gets current track progress as a percentage
   * 
   * @property completed
   * @readonly
   * @type {number}
   */
  public get completed() : number {
    return this._completed;
  }

  /**
   * Gets any errors logged by HTML5 audio
   *
   * @property error 
   * @readonly
   * @type {MediaError}
   */
  public get error() : MediaError {
    return this.audio.error;
  }
  
  /**
   * Gets a boolean value indicating whether the current source can be played
   * 
   * @property canPlay
   * @readonly
   * @type {boolean}
   */
  public get canPlay() : boolean {
    let format = &#x60;audio/${this.audio.src.substr(this.audio.src.lastIndexOf(&#x27;.&#x27;)+1)}&#x60;;
    return this.audio &amp;&amp; this.audio.canPlayType(format) != &#x27;&#x27;;
  }
  
  
  /**
   * Gets a boolean value indicating whether the track is in loading state
   * 
   * @property isLoading
   * @readonly
   * @type {boolean}
   */
  public get isLoading() : boolean {
    return this._isLoading;
  }
  
  
  /**
   * Gets a boolean value indicating whether the track has finished loading
   *
   * @property hadLoaded 
   * @readonly
   * @type {boolean}
   */
  public get hasLoaded() : boolean {
    return this._hasLoaded;
  }
  
  
  /**
   * Plays current track
   * 
   * @method play
   */
  play() {
    if (!this.audio) {
      this.createAudio(); 
    }
    
    if (!this._hasLoaded) {
      console.log(&#x60;Loading track ${this.src}&#x60;);
      this._isLoading = true;
    }
    
    //var source = this.ctx.createMediaElementSource(this.audio);  
    //source.connect(this.ctx.destination);
    this.audio.play();
  } 
  
  /**
   * Pauses current track
   *
   * @method pause 
   */
  pause() {
    if (!this.isPlaying) return;
    console.log(&#x60;Pausing track ${this.src}&#x60;);
    this.audio.pause();
    this.isPlaying = false;
  } 
  
  /**
   * Stops current track
   *
   * @method stop 
   */
  stop() {
    if (!this.audio) return;
    this.pause();
    this.audio.removeEventListener(&quot;timeupdate&quot;, (e) =&gt; { this.onTimeUpdate(e); });
    this.isFinished = true;
    this.destroy();
  }
  
  
  /**
   * Seeks to a new position within the track
   *
   * @method seekTo 
   * @param {number} time the new position to seek to
   */
  seekTo(time: number) {
    this.audio.currentTime = time;  
  }
  
  /**
   * Destroys this track instance
   * 
   * @method destroy
   */
  destroy() {
    this.audio = undefined;  
    console.log(&#x60;Released track ${this.src}&#x60;);
  }
}

/**
 * Cordova Media audio track
 * 
 * @export
 * @class CordovaAudioTrack
 * @constructor
 * @implements {IAudioTrack}
 */
@Injectable()
export class CordovaAudioTrack implements IAudioTrack {
  private audio: any;
  public isPlaying: boolean = false;
  public isFinished: boolean = false;
  private _progress: number;
  private _completed: number;
  private _duration: number;
  private _id: number;
  private _isLoading: boolean;
  private _hasLoaded: boolean;
  private _timer: any;
  
  constructor(public src: string) {
    if (window[&#x27;cordova&#x27;] === undefined || window[&#x27;Media&#x27;] === undefined) {
      console.log(&#x27;Cordova Media is not available&#x27;);
      return;
    };
    this.audio = new Media(src, () =&gt; {
       console.log(&#x27;Playback finished&#x27;)  
    }, (err) =&gt; {
      console.log(&#x27;Error&#x27;, err)    
    }, (status) =&gt; {
      console.log(&#x27;Status change&#x27;, status)
    });
  }
  
  private startTimer() {
    this._timer = setInterval(() =&gt; {  
      if (this._duration===undefined || this._duration &lt; 0) {
        this._duration = Math.round(this.audio.getDuration()*100)/100;
        console.log(this._duration + &quot; sec&quot;);
      }  
      
      this.audio.getCurrentPosition((position) =&gt; {
            if (position &gt; -1) {
              this._progress = Math.round(position*100)/100;
              this._completed = this._duration &gt; 0 ? Math.round(this._progress / this._duration * 100)/100 : 0; 
              console.log((position) + &quot; sec&quot;, &#x27;Completed&#x27;, this._completed);
            }
        }, (e) =&gt; {
            console.log(&quot;Error getting position&quot;, e);
        }
      );
    }, 1000);  
  }
  
  private stopTimer() {
    clearInterval(this._timer);
  }
  
  /** public members */

  /**
 * Gets the track id
 * 
 * @property id
 * @type {number}
 */
  public get id() : number {
    return this._id;
  }
  
  /**
 * Sets the track id
 * 
 * @property id
 */
  public set id(v : number) {
    this._id = v;
  }
  
  /**
 * Gets the track duration, or -1 if it cannot be determined
 * 
 * @property duration
 * @readonly
 * @type {number}
 */
  public get duration() : number {
    return this._duration;
  }
  
  /**
 * Gets current track time (progress)
 * 
 * @property progress
 * @readonly
 * @type {number}
 */
  public get progress() : number {
    return this._progress;
  } 
  
  /**
 * Gets current track progress as a percentage
 * 
 * @property completed
 * @readonly
 * @type {number}
 */
  public get completed() : number {
    return this._completed;
  }

/**
 * Gets any errors logged by HTML5 audio
 *
 * @property error 
 * @readonly
 * @type {MediaError}
 */
  public get error() : MediaError {
    return this.audio.error;
  }
  
  /**
 * Gets a boolean value indicating whether the current source can be played
 * 
 * @property canPlay
 * @readonly
 * @type {boolean}
 */
  public get canPlay() : boolean {
    return true;
  }
  
  /**
 * Gets a boolean value indicating whether the track is in loading state
 * 
 * @property isLoading
 * @readonly
 * @type {boolean}
 */
  public get isLoading() : boolean {
    return this._isLoading;
  }
  
  /**
 * Gets a boolean value indicating whether the track has finished loading
 *
 * @property hadLoaded 
 * @readonly
 * @type {boolean}
 */
  public get hasLoaded() : boolean {
    return this._hasLoaded;
  }
  
  /**
 * Plays current track
 * 
 * @method play
 */
  play() {
    this.audio.play();
    this.startTimer();
  }
  
  /**
 * Pauses current track
 *
 * @method pause 
 */
  pause() {
    this.audio.pause();
    this.stopTimer();  
  }
  
  /**
 * Stops current track
 *
 * @method stop 
 */
  stop() {
    this.audio.stop();
    this.stopTimer();  
  }
  
  /**
 * Seeks to a new position within the track
 *
 * @method seekTo 
 * @param {number} time the new position to seek to
 */
  seekTo(time: number) {
    this.audio.seekTo(time);
  }
  
  /**
   * Destroys this track instance
   * 
   * @method destroy
   */
  destroy() {
    this.audio.release();  
  }
}

/**
 * # &#x60;&#x60;&#x60;&lt;audio-track&gt;&#x60;&#x60;&#x60; 
 * 
 * Creates a top level audio-track component
 * 
 * ## Usage
 * 
 * &#x60;&#x60;&#x60;&#x60;
 *   &lt;audio-track #audio [track]=&quot;myTrack&quot; (onFinish)=&quot;onTrackFinished($event)&quot;&gt;
 *   ...
 *   &lt;/audio-track&gt;
 * &#x60;&#x60;&#x60;&#x60;
 * @element audio-track
 * @export
 * @class AudioTrackComponent
 */
@Component({
    selector: &#x27;audio-track&#x27;,
    template: &#x27;&lt;ng-content&gt;&lt;/ng-content&gt;&#x27;,
    providers: []
})
export class AudioTrackComponent { 
  /**
   * Input property containing a JSON object with at least a src property
   * &#x60;&#x60;&#x60;&#x60;
   *   this.myTrack = {
   *     src: &#x27;https://www,mysite.com/myTrack.mp3&#x27;,
   *     artist: &#x27;Artist name&#x27;,
   *     title: &#x27;...&#x27;,
   *     art: &#x27;img/artist.jpg&#x27;,
   *     preload: &#x27;metadata&#x27; // tell the plugin to preload metadata such as duration for this track
   *   };
   * &#x60;&#x60;&#x60;&#x60;
   * @property track
   * @type {ITrackConstraint}
   */
  @Input() track: ITrackConstraint;
  
  /**
   * Output property expects an event handler to be notified whenever playback finishes
   * 
   * @property onFinish
   * @type {EventEmitter}
   */
  @Output() onFinish = new EventEmitter&lt;ITrackConstraint&gt;();
  
  private _isFinished: boolean = false;
  private _audioTrack: IAudioTrack;
  
  constructor(private _audioProvider: AudioProvider) {}
  
  ngOnInit() {
    if (!(this.track instanceof AudioTrack)) {
      this._audioTrack = this._audioProvider.create(this.track); 
    } else {
      Object.assign(this._audioTrack, this.track);
      this._audioProvider.add(this._audioTrack);
    }
    
    // update input track parameter with track is so we pass it to WebAudioProvider if needed
    this.track.id = this._audioTrack.id; 
  }
  
  play() {    
    this._audioTrack.play();
    this._audioProvider.current = this._audioTrack.id;
  }
  
  pause() {
    this._audioTrack.pause();
    this._audioProvider.current = undefined;
  }
  
  toggle() {
    if (this._audioTrack.isPlaying) {
      this.pause();
    } else {
      this.play();
    }  
  }
  
  seekTo(time:number) {
    this._audioTrack.seekTo(time);  
  }
  
  
  public get id() : number {
    return this._audioTrack.id;
  }
  
  public get art() : string {
    return this.track.art;
  }
  
  
  public get artist() : string {
    return this.track.artist;
  }
  
  
  public get title() : string {
    return this.track.title;
  }
    
  public get progress() : number {
    return this._audioTrack.progress;
  }
      
  public get isPlaying() : boolean {
    return this._audioTrack.isPlaying;
  }
  
  public get duration() : number {
    return this._audioTrack.duration;
  }
  
  public get completed() : number {
    return this._audioTrack.completed;
  }
  
  public get canPlay() {
    return this._audioTrack.canPlay;
  }
  
  public get error() {
    return this._audioTrack.error;
  }
  
  public get isLoading() : boolean {
    return this._audioTrack.isLoading;
  }
  
  public get hasLoaded() : boolean {
    return this.hasLoaded;
  }
  
  ngDoCheck() {
    if(!Object.is(this._audioTrack.isFinished, this._isFinished)) {
      // some logic here to react to the change
      this._isFinished = this._audioTrack.isFinished;
      
      // track has stopped, trigger finish event
      if (this._isFinished) {
        this.onFinish.emit(this.track);       
      }
    }
  }
}

/**
 * # &#x60;&#x60;&#x60;&lt;audio-track-play&gt;&#x60;&#x60;&#x60; 
 * 
 * Renders a play/pause button that optionally displays a loading spinner
 * 
 * ## Usage
 * &#x60;&#x60;&#x60;&#x60;
 * &lt;audio-track #audio [track]=&quot;myTrack&quot; (onFinish)=&quot;onTrackFinished($event)&quot;&gt;
 *  &lt;ion-item&gt;  
 *    &lt;audio-track-play item-left [audioTrack]=&quot;audio&quot;&gt;&lt;ion-spinner&gt;&lt;/ion-spinner&gt;&lt;/audio-track-play&gt;
 *    &lt;h3&gt;{{audio.title}}&lt;/h3&gt;
 *  &lt;/ion-item&gt;    
 * &lt;/audio-track&gt;
 * &#x60;&#x60;&#x60;&#x60;
 * If placed within a &#x60;&#x60;&#x60;&lt;ion-thumnbail&gt;&#x60;&#x60;&#x60; component it will render as a semi-transparent button layover (see live demo). 
 * Passing a &#x60;&#x60;&#x60;&lt;ion-spinner&gt;&#x60;&#x60;&#x60; as a child element will display a loading spinner while loading.
 * 
 * &#x60;&#x60;&#x60;&#x60;
 * &lt;audio-track #audio [track]=&quot;track&quot; (onFinish)=&quot;onTrackFinished($event)&quot;&gt;
 *   &lt;ion-item&gt;  
 *       &lt;ion-thumbnail item-left&gt;
 *         &lt;img src=&quot;{{audio.art}}&quot;&gt;
 *         &lt;audio-track-play dark [audioTrack]=&quot;audio&quot;&gt;&lt;ion-spinner&gt;&lt;/ion-spinner&gt;&lt;/audio-track-play&gt;  
 *       &lt;/ion-thumbnail&gt;
 *       &lt;p&gt;&lt;strong&gt;{{audio.title}}&lt;/strong&gt;&lt;/p&gt;
 *   &lt;/ion-item&gt;    
 * &lt;/audio-track&gt;
 * &#x60;&#x60;&#x60;&#x60;
 * 
 * @element audio-track-play 
 * @parents audio-track
 * @export
 * @class AudioTrackPlayComponent
 */
@Component({
    selector: &#x27;audio-track-play&#x27;,
    template: &#x60;
    &lt;button clear (click)=&quot;toggle($event)&quot; [disabled]=&quot;audioTrack.error || audioTrack.isLoading&quot;&gt;
      &lt;ion-icon name=&quot;pause&quot; *ngIf=&quot;audioTrack.isPlaying &amp;&amp; !audioTrack.isLoading&quot;&gt;&lt;/ion-icon&gt;
      &lt;ion-icon name=&quot;play&quot; *ngIf=&quot;!audioTrack.isPlaying &amp;&amp; !audioTrack.isLoading&quot;&gt;&lt;/ion-icon&gt;
      &lt;ng-content *ngIf=&quot;audioTrack.isLoading &amp;&amp; !audioTrack.error&quot;&gt;&lt;/ng-content&gt;
    &lt;/button&gt;
    &#x60;,
    directives: [Icon]
})
export class AudioTrackPlayComponent {
  private _isPlaying: boolean = false;
  private _isLoading: boolean = false;
  
  /**
   * The AudioTrackComponent parent instance created by &#x60;&#x60;&#x60;&lt;audio-track&gt;&#x60;&#x60;&#x60;
   * 
   * @property @Input() audioTrack
   * @type {IAudioTrack}
   */
  @Input() audioTrack: IAudioTrack;
  
  /**
   * Renders the component using the light theme
   * 
   * @property @Input() light
   * @type {boolean}
   */
  @Input()
  set light(val: boolean) {
    this.el.nativeElement.firstElementChild.classList.add(&#x27;light&#x27;);
  }
  
  /**
   * Renders the component using the dark theme
   * 
   * @property @Input() dark
   * @type {boolean}
   */
  @Input()
  set dark(val: boolean) {
    this.el.nativeElement.firstElementChild.classList.add(&#x27;dark&#x27;); 
  }
  
  constructor(private el: ElementRef) {}
  
  toggle(){    
    if (this.audioTrack.isPlaying) {
      this.audioTrack.pause()
    } else {
      this.audioTrack.play()
    } 
  }
}

/**
 * A pipe to convert milliseconds to a string representation
 * 
 * @export
 * @class AudioTimePipe
 * @implements {PipeTransform}
 */
@Pipe({name: &#x27;audioTime&#x27;})
export class AudioTimePipe implements PipeTransform {
  
  /**
   * Transforms milliseconds to hh:mm:ss
   * 
   * @method transform
   * @param {number} [value] The milliseconds
   * @return {string} hh:mm:ss
   */
  transform(value?:number) : string {    
    if (!value) return &#x27;&#x27;;
    let s = Math.trunc(value % 60);
    let m = Math.trunc((value / 60) % 60);
    let h = Math.trunc(((value / 60) / 60) % 60);  
    return h &gt; 0 ? &#x60;${h&lt;10?&#x27;0&#x27;+h:h}:${m&lt;10?&#x27;0&#x27;+m:m}:${s&lt;10?&#x27;0&#x27;+s:s}&#x60; : &#x60;${m&lt;10?&#x27;0&#x27;+m:m}:${s&lt;10?&#x27;0&#x27;+s:s}&#x60;;
  }
}

/**
 * # &#x60;&#x60;&#x60;&lt;audio-track-progress&gt;&#x60;&#x60;&#x60; 
 * 
 * Renders a timer component displaying track progress and duration 
 * 
 * ## Usage
 * &#x60;&#x60;&#x60;&#x60;
 * &lt;audio-track-progress [audioTrack]=&quot;track&quot;&gt;&lt;/audio-track-progress&gt;
 * &#x60;&#x60;&#x60;&#x60;
 * 
 * @element audio-track-progress
 * @parents audio-track
 * @export
 * @class AudioTrackProgressComponent
 */
@Component({
    selector: &#x27;audio-track-progress&#x27;,
    template: &#x27;&lt;em *ngIf=&quot;audioTrack.completed &gt; 0&quot;&gt;{{audioTrack.progress | audioTime}} / &lt;/em&gt;&lt;em&gt;{{audioTrack.duration | audioTime}}&lt;/em&gt;&#x27;,
    pipes: [AudioTimePipe]
})
export class AudioTrackProgressComponent {
  /**
   * The AudioTrackComponent parent instance created by &#x60;&#x60;&#x60;&lt;audio-track&gt;&#x60;&#x60;&#x60;
   * 
   * @property @Input() audioTrack
   * @type {IAudioTrack}
   */
  @Input() audioTrack: IAudioTrack;  
}

/**
 * # &#x60;&#x60;&#x60;&lt;audio-track-progress-bar&gt;&#x60;&#x60;&#x60;
 * 
 * Renders a progress bar with optional timer, duration and progress indicator that allow seeking
 * 
 * ## Usage
 * &#x60;&#x60;&#x60;&#x60;
 *  &lt;audio-track-progress-bar dark duration progress [audioTrack]=&quot;audio&quot;&gt;&lt;/audio-track-progress-bar&gt;
 * &#x60;&#x60;&#x60;&#x60;
 * 
 * @element audio-track-progress-bar
 * @parents audio-track
 * @export
 * @class AudioTrackProgressBarComponent
 */
@Component({
    selector: &#x27;audio-track-progress-bar&#x27;,
    template: &#x60;&lt;time *ngIf=&quot;_showProgress&quot;&gt;{{audioTrack.progress | audioTime}}&lt;/time&gt;
    &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;1&quot; [(ngModel)]=&quot;_range&quot; [ngStyle]=&quot;{&#x27;visibility&#x27;: _completed &gt; 0 ? &#x27;visible&#x27; : &#x27;hidden&#x27;}&quot;&gt;
    &lt;time *ngIf=&quot;_showDuration&quot;&gt;{{audioTrack.duration | audioTime}}&lt;/time&gt;
    &#x60;,
    pipes: [AudioTimePipe],
    directives: [NgStyle]
})
export class AudioTrackProgressBarComponent {
  /**
   * The AudioTrackComponent parent instance created by &#x60;&#x60;&#x60;&lt;audio-track&gt;&#x60;&#x60;&#x60;
   * 
   * @property @Input() audioTrack
   * @type {IAudioTrack}
   */
  @Input() audioTrack: IAudioTrack;
  
  private _completed: number = 0;
  private _range: number = 0;
  private _showDuration: boolean;
  private _showProgress: boolean;
  constructor(private el: ElementRef) { 
  }
  
  /**
   * Input property indicating whether to display track progress 
   * 
   * @property @Input() progress
   * @type {boolean}
   */
  @Input()
  public set progress(v : boolean) {
    this._showProgress = true;
  }
  
  /**
   * Input property indicating whether to display track duration 
   * 
   * @property @Input() duration
   * @type {boolean}
   */
  @Input()
  public set duration(v:  boolean) {
    this._showDuration = true;
  }
  
  /**
   * Renders the component using the light theme
   * 
   * @property @Input() light
   * @type {boolean}
   */
  @Input()
  set light(val: boolean) {
    this.el.nativeElement.querySelector(&quot;input&quot;).classList.add(&#x27;light&#x27;);
  }
  
  /**
   * Renders the component using the dark theme
   * 
   * @property @Input() dark
   * @type {boolean}
   */
  @Input()
  set dark(val: boolean) {
    this.el.nativeElement.querySelector(&quot;input&quot;).classList.add(&#x27;dark&#x27;); 
  }
  
  ngOnInit() {
    this.el.nativeElement.querySelector(&quot;input&quot;).addEventListener(&quot;input&quot;, (e) =&gt; { 
      this.seekTo();
    }, false);
        
  }
  
  ngDoCheck() {
    if(this.audioTrack.completed &gt; 0 &amp;&amp; !Object.is(this.audioTrack.completed, this._completed)) {
      this._completed = this.audioTrack.completed; 
      this._range = Math.round(this._completed*100*100)/100;
    }
  }
  
  seekTo() {
    let seekTo: number = Math.round(this.audioTrack.duration*this._range)/100;
    this.audioTrack.seekTo(seekTo);   
  }
}

/*
@Component({
    selector: &#x27;audio-track-progress-slider&#x27;,
    template: &#x60;&#x60;,
    directives: [NgStyle]
})
export class AudioTrackProgressSliderComponent extends DragGesture {
  @Input() audioTrack: IAudioTrack;
  @Output() onSeek = new EventEmitter&lt;any&gt;();
  private _completed: number = 0;
  constructor(private el: ElementRef) { 
    super(el.nativeElement);
  }
  
  ngOnInit() {      
    super.listen();  
  }
  
  ngDoCheck() {
    if(this.audioTrack.completed &gt; 0 &amp;&amp; !Object.is(this.audioTrack.completed, this._completed)) {
      
    }
  }
  
  onDrag(ev) {
  // console.log(ev)
    return super.onDrag(ev);
  };
  onDragStart(ev)  {
  // console.log(ev);
    return super.onDragStart(ev);
  };         
  onDragEnd(ev) {
    this.onSeek.emit(ev);
    return super.onDragEnd(ev);
  };  
}
*/
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
